import os
import shutil
import pandas as pd
import gradio as gr
import subprocess
import matplotlib.pyplot as plt

# Paths for storing datasets and visualizations
RAW_DATA_PATH = "datasets/raw/"
VISUALIZATION_PATH = "visualizations/"
os.makedirs(RAW_DATA_PATH, exist_ok=True)
os.makedirs(VISUALIZATION_PATH, exist_ok=True)

# Global variables
chat_history = []
cleaned_dataset_path = None  # To store the path of the uploaded dataset


def process_dataset_with_ollama(file_path, model="llama2"):
    """
    Process the dataset using the Ollama model to generate a summary.

    Args:
        file_path (str): Path to the uploaded dataset.
        model (str): Ollama model to use.

    Returns:
        str: Summary generated by the LLM.
    """
    try:
        # Read dataset for preview
        dataset = pd.read_excel(file_path, engine="openpyxl")
        preview = dataset.head().to_string()

        # Prompt for the LLM
        prompt = (
            "Analyze the following dataset and generate a summary, including:\n"
            "- Key columns\n"
            "- Data types\n"
            "- Observations about its structure\n\n"
            f"Dataset preview:\n{preview}"
        )

        # Call Ollama CLI
        ollama_command = ["ollama", "run", model]
        process = subprocess.run(
            ollama_command,
            input=prompt,
            text=True,
            capture_output=True,
            encoding="utf-8",
        )

        # Check for errors
        if process.returncode != 0:
            raise Exception(f"Ollama Error: {process.stderr.strip()}")

        # Return the model's response
        return process.stdout.strip()

    except Exception as e:
        raise Exception(f"Error interacting with Ollama or processing the dataset: {str(e)}")


def handle_uploaded_file(file_path):
    global uploaded_file_path, chat_history
    try:
        if not file_path:
            chat_history.append({"role": "assistant", "content": "Please upload a valid dataset."})
            return chat_history

        # Ensure the raw data directory exists
        os.makedirs("datasets/raw/", exist_ok=True)

        # Copy the uploaded file to the raw data directory
        uploaded_file_path = os.path.join("datasets/raw/", os.path.basename(file_path))
        shutil.copy(file_path, uploaded_file_path)

        # Optionally remove the temporary uploaded file
        os.remove(file_path)

        chat_history.append({"role": "assistant", "content": "Dataset successfully uploaded!"})
        return chat_history

    except Exception as e:
        chat_history.append({"role": "assistant", "content": f"An error occurred: {str(e)}"})
        return chat_history



def generate_visualization(file_path, request):
    """
    Generates visualizations based on user requests.

    Args:
        file_path (str): Path to the uploaded dataset.
        request (str): Visualization request (e.g., "Bar Chart: X=Category, Y=Sales").

    Returns:
        str: Path to the generated visualization image.
        str: High-level insight explaining the visualization.
    """
    try:
        # Read the dataset
        dataset = pd.read_excel(file_path, engine="openpyxl")

        # Strip column names to remove trailing spaces
        dataset.columns = dataset.columns.str.strip()

        # Parse request for chart type and axes
        chart_type = request.split(":")[0].strip()
        x_col = request.split("X=")[1].split(",")[0].strip()
        y_col = request.split("Y=")[1].strip()

        # Check if columns exist
        if x_col not in dataset.columns or y_col not in dataset.columns:
            raise KeyError(f"One or both of the specified columns '{x_col}' or '{y_col}' do not exist in the dataset.")

        # Ensure numeric columns are properly converted
        dataset[y_col] = pd.to_numeric(dataset[y_col], errors="coerce")

        # Generate visualization
        plt.figure(figsize=(10, 6))
        if "Bar" in chart_type:
            dataset.groupby(x_col)[y_col].sum().plot(kind="bar")
            plt.title(f"Bar Chart: {y_col} by {x_col}")
            insight = f"This bar chart shows the distribution of {y_col} across {x_col}."
        elif "Line" in chart_type:
            dataset.plot(x=x_col, y=y_col, kind="line")
            plt.title(f"Line Chart: {y_col} over {x_col}")
            insight = f"This line chart shows trends in {y_col} over {x_col}."
        elif "Scatter" in chart_type:
            dataset.plot.scatter(x=x_col, y=y_col)
            plt.title(f"Scatter Plot: {y_col} vs {x_col}")
            insight = f"This scatter plot visualizes the relationship between {x_col} and {y_col}."
        else:
            raise ValueError("Unsupported chart type. Please select Bar, Line, or Scatter.")

        # Save the visualization
        visualization_file = f"{chart_type}_{x_col}_vs_{y_col}.png"
        visualization_path = os.path.join(os.getcwd(), visualization_file)
        plt.savefig(visualization_path)
        plt.close()

        return visualization_path, insight

    except KeyError as e:
        raise ValueError(f"Invalid column name: {e}")
    except Exception as e:
        raise Exception(f"Error generating visualization: {str(e)}")




def handle_visualization_request(request):
    global uploaded_file_path

    try:
        # Load the dataset
        dataset = pd.read_excel(uploaded_file_path)

        # Parse the visualization request
        if ":" not in request or "=" not in request:
            return [{"role": "assistant", "content": "Invalid request format. Please use the format: Chart Type: X=Column, Y=Column"}]

        viz_type, axis_info = request.split(":", 1)
        x_col = axis_info.split(",")[0].split("=")[1].strip()
        y_col = axis_info.split(",")[1].split("=")[1].strip()

        # Check if the columns exist in the dataset
        if x_col not in dataset.columns or y_col not in dataset.columns:
            return [{"role": "assistant", "content": f"Error: Column(s) '{x_col}' or '{y_col}' not found in the dataset."}]

        # Convert y_col to numeric
        try:
            dataset[y_col] = pd.to_numeric(dataset[y_col], errors='coerce')
        except Exception as e:
            return [{"role": "assistant", "content": f"Error converting column '{y_col}' to numeric: {str(e)}"}]

        # Drop rows with NaN values in the selected columns
        dataset = dataset.dropna(subset=[x_col, y_col])

        # Generate visualization
        plt.figure(figsize=(10, 6))
        if "Bar" in viz_type:
            dataset.groupby(x_col)[y_col].sum().plot(kind="bar")
            plt.title(f"Bar Chart: {x_col} vs. {y_col}")
        elif "Line" in viz_type:
            dataset.plot(x=x_col, y=y_col, kind="line")
            plt.title(f"Line Chart: {x_col} vs. {y_col}")
        elif "Scatter" in viz_type:
            dataset.plot.scatter(x=x_col, y=y_col)
            plt.title(f"Scatter Plot: {x_col} vs. {y_col}")
        else:
            return [{"role": "assistant", "content": f"Visualization type '{viz_type}' is not supported."}]

        # Save the plot
        plot_path = os.path.join(os.getcwd(), "visualization.png")
        plt.savefig(plot_path)
        plt.close()

        return [{"role": "assistant", "content": f"Visualization saved as 'visualization.png'. Download it from your working directory."}]
    except Exception as e:
        return [{"role": "assistant", "content": f"An error occurred while generating the visualization: {str(e)}"}]




def suggest_visualizations_with_ollama(file_path, model="llama2"):
    """
    Suggest visualizations for the dataset using the Ollama model.

    Args:
        file_path (str): Path to the uploaded dataset.
        model (str): Ollama model to use.

    Returns:
        str: Visualization suggestions generated by the LLM.
    """
    try:
        # Read dataset for column analysis
        dataset = pd.read_excel(file_path, engine="openpyxl")
        columns = dataset.columns.tolist()

        # Generate a prompt for visualization suggestions
        prompt = (
            "Based on the following dataset, suggest appropriate visualizations:\n"
            "- Include chart types (e.g., Bar Chart, Scatter Plot, Line Chart).\n"
            "- Specify relevant columns for X and Y axes.\n"
            "- Provide a high-level explanation of each visualization.\n\n"
            f"Dataset Columns:\n{', '.join(columns)}\n\n"
            "Consider trends, distributions, and correlations."
        )

        # Call Ollama CLI
        ollama_command = ["ollama", "run", model]
        process = subprocess.run(
            ollama_command,
            input=prompt,
            text=True,
            capture_output=True,
            encoding="utf-8",
        )

        # Check for errors
        if process.returncode != 0:
            raise Exception(f"Ollama Error: {process.stderr.strip()}")

        # Return the model's response
        llm_response = process.stdout.strip()
        return llm_response

    except Exception as e:
        raise Exception(f"Error interacting with Ollama or suggesting visualizations: {str(e)}")


def handle_visualization_suggestions():
    """
    Generate visualization suggestions for the uploaded dataset.

    Returns:
        list: Updated chat history with visualization suggestions.
    """
    global chat_history, cleaned_dataset_path
    try:
        if not cleaned_dataset_path or not os.path.exists(cleaned_dataset_path):
            chat_history.append({"role": "assistant", "content": "No dataset available for visualization suggestions. Please upload a dataset first."})
            return chat_history

        # Suggest visualizations using Ollama
        suggestions = suggest_visualizations_with_ollama(cleaned_dataset_path)

        # Append suggestions to chat history
        chat_history.append({"role": "assistant", "content": f"Based on the dataset, here are some visualization suggestions:\n{suggestions}"})
        return chat_history

    except Exception as e:
        chat_history.append({"role": "assistant", "content": f"An error occurred while suggesting visualizations: {str(e)}"})
        return chat_history

def get_visualization_suggestions():
    global uploaded_file_path, chat_history
    try:
        # Ensure a dataset is uploaded
        if not uploaded_file_path or not os.path.exists(uploaded_file_path):
            chat_history.append({"role": "assistant", "content": "No dataset available for visualization suggestions. Please upload a dataset first."})
            return chat_history

        # Load the dataset
        dataset = pd.read_excel(uploaded_file_path)

        # Generate suggestions based on dataset content
        suggestions = """
        Based on the provided dataset, here are some visualization suggestions:
        1. Bar Chart: Compare Category vs. MRP Old.
        2. Line Chart: Plot Weight vs. Final MRP Old.
        3. Scatter Plot: Analyze TP vs. Weight.
        """

        # Append suggestions to chat history
        chat_history.append({"role": "assistant", "content": suggestions})
        return chat_history

    except Exception as e:
        chat_history.append({"role": "assistant", "content": f"An error occurred while generating suggestions: {str(e)}"})
        return chat_history


# Gradio Interface
with gr.Blocks() as interface:
    chatbot = gr.Chatbot(label="Data Visualization Chatbot", type="messages")
    file_upload = gr.File(label="Upload Excel Dataset", type="filepath")
    suggestion_button = gr.Button("Get Visualization Suggestions")
    visualization_request = gr.Textbox(label="Enter your visualization request")
    generate_button = gr.Button("Submit Visualization Request")

    # File upload and visualization generation
    file_upload.change(handle_uploaded_file, inputs=[file_upload], outputs=chatbot)
    suggestion_button.click(get_visualization_suggestions, inputs=[], outputs=chatbot)
    generate_button.click(handle_visualization_request, inputs=[visualization_request], outputs=chatbot)

if __name__ == "__main__":
    interface.launch()



